// Code generated by github.com/STRockefeller/linqable Do NOT EDIT.

package impl

import (
	"fmt"
	"reflect"

	"gitlab.kenda.com.tw/kenda/mcom/impl/orm/models"
)

// Users definition.
type Users []models.User

// NewLinqableUser returns a new Users from the input models.User.
func NewLinqableUser(si []models.User) Users {
	return si
}

// RepeatLinqableUser generates a sequence that contains one repeated value.
func RepeatLinqableUser(element models.User, count int) Users {
	si := NewLinqableUser([]models.User{})
	for i := 0; i < count; i++ {
		si = si.Append(element)
	}
	return si
}

// Where filters a sequence of values based on a predicate.
func (si Users) Where(predicate func(models.User) bool) Users {
	res := []models.User{}
	for _, elem := range si {
		if predicate(elem) {
			res = append(res, elem)
		}
	}
	return res
}

// Reverse inverts the order of the elements in a sequence.
func (si Users) Reverse(predicate func(models.User) bool) Users {
	res := NewLinqableUser(make([]models.User, len(si)))
	for i, j := 0, len(si)-1; i < j; i, j = i+1, j-1 {
		res[i], res[j] = si[j], si[i]
	}
	return res
}

// Contains determines whether a sequence contains a specified element.
func (si Users) Contains(target models.User) bool {
	for _, elem := range si {
		if reflect.DeepEqual(elem, target) {
			return true
		}
	}
	return false
}

// Count returns  a number that represents how many elements in the specified sequence satisfy a condition.
func (si Users) Count(predicate func(models.User) bool) int {
	var count int
	for _, elem := range si {
		if predicate(elem) {
			count++
		}
	}
	return count
}

// Any determines whether any element of a sequence satisfies a condition.
func (si Users) Any(predicate func(models.User) bool) bool {
	for _, elem := range si {
		if predicate(elem) {
			return true
		}
	}
	return false
}

// All determines whether all elements of a sequence satisfy a condition.
func (si Users) All(predicate func(models.User) bool) bool {
	for _, elem := range si {
		if predicate(elem) {
			continue
		} else {
			return false
		}
	}
	return true
}

// Append appends a value to the end of the sequence.
func (si Users) Append(newItem models.User) Users {
	return append(si, newItem)
}

// Prepend adds a value to the beginning of the sequence.
func (si Users) Prepend(newItem models.User) Users {
	return append([]models.User{newItem}, si.ToSlice()...)
}

// Distinct returns distinct elements from a sequence by using the default equality comparer to compare values.
func (si Users) Distinct() Users {
	res := si.Empty()
	for _, elem := range si {
		if !res.Contains(elem) {
			res = res.Append(elem)
		}
	}
	return res
}

// ElementAt returns the element at a specified index in a sequence.
func (si Users) ElementAt(index int) models.User {
	if index >= len(si) {
		panic("linq: ElementAt() out of index")
	}
	return si[index]
}

// ElementAtOrDefault returns the element at a specified index in a sequence or a default value if the index is out of range.
func (si Users) ElementAtOrDefault(index int) models.User {
	var defaultValue models.User
	if index >= len(si) {
		return defaultValue
	}
	return si[index]
}

// Empty returns empty Users that has the specified type argument.
func (si Users) Empty() Users {
	return NewLinqableUser([]models.User{})
}

// First returns the first element in a sequence that satisfies a specified condition.
func (si Users) First(predicate func(models.User) bool) models.User {
	if len(si) <= 0 {
		panic("linq: First() empty set")
	}
	for _, elem := range si {
		if predicate(elem) {
			return elem
		}
	}
	panic("linq: First() no match element in the slice")
}

// FirstOrDefault returns the first element of a sequence, or a default value if the sequence contains no elements.
func (si Users) FirstOrDefault(predicate func(models.User) bool) models.User {
	var defaultValue models.User
	if len(si) <= 0 {
		return defaultValue
	}
	for _, elem := range si {
		if predicate(elem) {
			return elem
		}
	}
	return defaultValue
}

// Last returns the last element in a sequence that satisfies a specified condition.
func (si Users) Last(predicate func(models.User) bool) models.User {
	if len(si) <= 0 {
		panic("linq: Last() empty set")
	}
	for i := len(si) - 1; i >= 0; i-- {
		if predicate(si[i]) {
			return si[i]
		}
	}
	panic("linq: Last() no match element in the slice")
}

// LastOrDefault returns the last element of a sequence, or a default value if the sequence contains no elements.
func (si Users) LastOrDefault(predicate func(models.User) bool) models.User {
	var defaultValue models.User
	if len(si) <= 0 {
		return defaultValue
	}
	for i := len(si) - 1; i >= 0; i-- {
		if predicate(si[i]) {
			return si[i]
		}
	}
	return defaultValue
}

// Single returns the only element of a sequence that satisfies a specified condition, and returns a panic if more than one such element exists.
func (si Users) Single(predicate func(models.User) bool) models.User {
	if len(si) <= 0 {
		panic("linq: Single() empty set")
	}
	if si.Count(predicate) == 1 {
		return si.First(predicate)
	}
	panic("linq: Single() eligible data count is not unique")
}

// SingleOrDefault returns the only element of a sequence, or a default value if the sequence is empty; this method returns a panic if there is more than one element in the sequence.
func (si Users) SingleOrDefault(predicate func(models.User) bool) models.User {
	var defaultValue models.User
	if len(si) <= 0 {
		return defaultValue
	}
	if si.Count(predicate) == 1 {
		return si.First(predicate)
	}
	panic("linq: SingleOrDefault() eligible data count is not unique")
}

// Take returns a specified number of contiguous elements from the start of a sequence.
func (si Users) Take(n int) Users {
	if n < 0 || n >= len(si) {
		panic("Linq: Take() out of index")
	}
	res := []models.User{}
	for i := 0; i < n; i++ {
		res = append(res, si[i])
	}
	return res
}

// TakeWhile returns elements from a sequence as long as a specified condition is true, and then skips the remaining elements.
func (si Users) TakeWhile(predicate func(models.User) bool) Users {
	res := []models.User{}
	for i := 0; i < len(si); i++ {
		if predicate(si[i]) {
			res = append(res, si[i])
		} else {
			return res
		}
	}
	return res
}

// TakeLast returns a new Users that contains the last count elements from source.
func (si Users) TakeLast(n int) Users {
	if n < 0 || n >= len(si) {
		panic("Linq: TakeLast() out of index")
	}
	return si.Skip(len(si) - n)
}

// Skip bypasses a specified number of elements in a sequence and then returns the remaining elements.
func (si Users) Skip(n int) Users {
	if n < 0 || n >= len(si) {
		panic("Linq: Skip() out of index")
	}
	return si[n:]
}

// SkipWhile bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements.
func (si Users) SkipWhile(predicate func(models.User) bool) Users {
	for i := 0; i < len(si); i++ {
		if predicate(si[i]) {
			continue
		} else {
			return si[i:]
		}
	}
	return Users{}
}

// SkipLast returns a new enumerable collection that contains the elements from source with the last count elements of the source collection omitted.
func (si Users) SkipLast(n int) Users {
	if n < 0 || n > len(si) {
		panic("Linq: SkipLast() out of index")
	}
	return si.Take(len(si) - n)
}

// SumInt32 computes the sum of a sequence of numeric values.
func (si Users) SumInt32(selector func(models.User) int32) int32 {
	var sum int32
	for _, elem := range si {
		sum += selector(elem)
	}
	return sum
}

// SumInt16 computes the sum of a sequence of numeric values.
func (si Users) SumInt16(selector func(models.User) int16) int16 {
	var sum int16
	for _, elem := range si {
		sum += selector(elem)
	}
	return sum
}

// SumInt64 computes the sum of a sequence of numeric values.
func (si Users) SumInt64(selector func(models.User) int64) int64 {
	var sum int64
	for _, elem := range si {
		sum += selector(elem)
	}
	return sum
}

// SumFloat32 computes the sum of a sequence of numeric values.
func (si Users) SumFloat32(selector func(models.User) float32) float32 {
	var sum float32
	for _, elem := range si {
		sum += selector(elem)
	}
	return sum
}

// SumFloat64 computes the sum of a sequence of numeric values.
func (si Users) SumFloat64(selector func(models.User) float64) float64 {
	var sum float64
	for _, elem := range si {
		sum += selector(elem)
	}
	return sum
}

// ToSlice create a/an Users from a/an models.User.
func (si Users) ToSlice() []models.User {
	return si
}

// #region not linq

// ForEach executes the provided callback once for each element present in the Users in ascending order.
func (si Users) ForEach(callBack func(models.User)) {
	for _, elem := range si {
		callBack(elem)
	}
}

// ReplaceAll replaces all oldValues with newValues in the Users.
func (si Users) ReplaceAll(oldValue, newValue models.User) Users {
	res := NewLinqableUser([]models.User{})
	for _, elem := range si {
		if reflect.DeepEqual(elem, oldValue) {
			res = res.Append(newValue)
		} else {
			res = res.Append(elem)
		}
	}
	return res
}

// Remove removes the first occurrence of a specific object from the Users.
func (si *Users) Remove(item models.User) bool {
	res := NewLinqableUser([]models.User{})
	var isRemoved bool
	for _, elem := range *si {
		if reflect.DeepEqual(elem, item) && !isRemoved {
			isRemoved = true
			continue
		}
		res = res.Append(elem)
	}
	*si = res
	return isRemoved
}

// RemoveAll removes all the elements that match the conditions defined by the specified predicate.
func (si *Users) RemoveAll(predicate func(models.User) bool) int {
	var count int
	res := NewLinqableUser([]models.User{})
	for _, elem := range *si {
		if predicate(elem) {
			count++
			continue
		}
		res = res.Append(elem)
	}
	*si = res
	return count
}

// RemoveAt removes the element at the specified index of the Users.
func (si *Users) RemoveAt(index int) {
	res := NewLinqableUser([]models.User{})
	for i := 0; i < len(*si); i++ {
		if i == index {
			continue
		}
		res = res.Append((*si)[i])
	}
	*si = res
}

// RemoveRange removes a range of elements from the Users.
func (si *Users) RemoveRange(index, count int) error {
	if index < 0 || count < 0 || index+count > len(*si) {
		return fmt.Errorf("argument out of range")
	}
	res := NewLinqableUser([]models.User{})
	for i := 0; i < len(*si); i++ {
		if i >= index && count != 0 {
			count--
			continue
		}
		res = res.Append((*si)[i])
	}
	*si = res
	return nil
}

// #endregion not linq
