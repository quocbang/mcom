// Code generated by github.com/STRockefeller/linqable Do NOT EDIT.

package impl

import (
	"fmt"
	"reflect"

	"gitlab.kenda.com.tw/kenda/mcom/impl/orm/models"
)

// Accounts definition.
type Accounts []models.Account

// NewAccounts returns a new Accounts from the input models.Account.
func NewAccounts(si []models.Account) Accounts {
	return si
}

// RepeatAccounts generates a sequence that contains one repeated value.
func RepeatAccounts(element models.Account, count int) Accounts {
	si := NewAccounts([]models.Account{})
	for i := 0; i < count; i++ {
		si = si.Append(element)
	}
	return si
}

// Where filters a sequence of values based on a predicate.
func (si Accounts) Where(predicate func(models.Account) bool) Accounts {
	res := []models.Account{}
	for _, elem := range si {
		if predicate(elem) {
			res = append(res, elem)
		}
	}
	return res
}

// Reverse inverts the order of the elements in a sequence.
func (si Accounts) Reverse(predicate func(models.Account) bool) Accounts {
	res := NewAccounts(make([]models.Account, len(si)))
	for i, j := 0, len(si)-1; i < j; i, j = i+1, j-1 {
		res[i], res[j] = si[j], si[i]
	}
	return res
}

// Contains determines whether a sequence contains a specified element.
func (si Accounts) Contains(target models.Account) bool {
	for _, elem := range si {
		if reflect.DeepEqual(elem, target) {
			return true
		}
	}
	return false
}

// Count returns  a number that represents how many elements in the specified sequence satisfy a condition.
func (si Accounts) Count(predicate func(models.Account) bool) int {
	var count int
	for _, elem := range si {
		if predicate(elem) {
			count++
		}
	}
	return count
}

// Any determines whether any element of a sequence satisfies a condition.
func (si Accounts) Any(predicate func(models.Account) bool) bool {
	for _, elem := range si {
		if predicate(elem) {
			return true
		}
	}
	return false
}

// All determines whether all elements of a sequence satisfy a condition.
func (si Accounts) All(predicate func(models.Account) bool) bool {
	for _, elem := range si {
		if predicate(elem) {
			continue
		} else {
			return false
		}
	}
	return true
}

// Append appends a value to the end of the sequence.
func (si Accounts) Append(newItem models.Account) Accounts {
	return append(si, newItem)
}

// Prepend adds a value to the beginning of the sequence.
func (si Accounts) Prepend(newItem models.Account) Accounts {
	return append([]models.Account{newItem}, si.ToSlice()...)
}

// Distinct returns distinct elements from a sequence by using the default equality comparer to compare values.
func (si Accounts) Distinct() Accounts {
	res := si.Empty()
	for _, elem := range si {
		if !res.Contains(elem) {
			res = res.Append(elem)
		}
	}
	return res
}

// ElementAt returns the element at a specified index in a sequence.
func (si Accounts) ElementAt(index int) models.Account {
	if index >= len(si) {
		panic("linq: ElementAt() out of index")
	}
	return si[index]
}

// ElementAtOrDefault returns the element at a specified index in a sequence or a default value if the index is out of range.
func (si Accounts) ElementAtOrDefault(index int) models.Account {
	var defaultValue models.Account
	if index >= len(si) {
		return defaultValue
	}
	return si[index]
}

// Empty returns empty Accounts that has the specified type argument.
func (si Accounts) Empty() Accounts {
	return NewAccounts([]models.Account{})
}

// First returns the first element in a sequence that satisfies a specified condition.
func (si Accounts) First(predicate func(models.Account) bool) models.Account {
	if len(si) <= 0 {
		panic("linq: First() empty set")
	}
	for _, elem := range si {
		if predicate(elem) {
			return elem
		}
	}
	panic("linq: First() no match element in the slice")
}

// FirstOrDefault returns the first element of a sequence, or a default value if the sequence contains no elements.
func (si Accounts) FirstOrDefault(predicate func(models.Account) bool) models.Account {
	var defaultValue models.Account
	if len(si) <= 0 {
		return defaultValue
	}
	for _, elem := range si {
		if predicate(elem) {
			return elem
		}
	}
	return defaultValue
}

// Last returns the last element in a sequence that satisfies a specified condition.
func (si Accounts) Last(predicate func(models.Account) bool) models.Account {
	if len(si) <= 0 {
		panic("linq: Last() empty set")
	}
	for i := len(si) - 1; i >= 0; i-- {
		if predicate(si[i]) {
			return si[i]
		}
	}
	panic("linq: Last() no match element in the slice")
}

// LastOrDefault returns the last element of a sequence, or a default value if the sequence contains no elements.
func (si Accounts) LastOrDefault(predicate func(models.Account) bool) models.Account {
	var defaultValue models.Account
	if len(si) <= 0 {
		return defaultValue
	}
	for i := len(si) - 1; i >= 0; i-- {
		if predicate(si[i]) {
			return si[i]
		}
	}
	return defaultValue
}

// Single returns the only element of a sequence that satisfies a specified condition, and returns a panic if more than one such element exists.
func (si Accounts) Single(predicate func(models.Account) bool) models.Account {
	if len(si) <= 0 {
		panic("linq: Single() empty set")
	}
	if si.Count(predicate) == 1 {
		return si.First(predicate)
	}
	panic("linq: Single() eligible data count is not unique")
}

// SingleOrDefault returns the only element of a sequence, or a default value if the sequence is empty; this method returns a panic if there is more than one element in the sequence.
func (si Accounts) SingleOrDefault(predicate func(models.Account) bool) models.Account {
	var defaultValue models.Account
	if len(si) <= 0 {
		return defaultValue
	}
	if si.Count(predicate) == 1 {
		return si.First(predicate)
	}
	panic("linq: SingleOrDefault() eligible data count is not unique")
}

// Take returns a specified number of contiguous elements from the start of a sequence.
func (si Accounts) Take(n int) Accounts {
	if n < 0 || n >= len(si) {
		panic("Linq: Take() out of index")
	}
	res := []models.Account{}
	for i := 0; i < n; i++ {
		res = append(res, si[i])
	}
	return res
}

// TakeWhile returns elements from a sequence as long as a specified condition is true, and then skips the remaining elements.
func (si Accounts) TakeWhile(predicate func(models.Account) bool) Accounts {
	res := []models.Account{}
	for i := 0; i < len(si); i++ {
		if predicate(si[i]) {
			res = append(res, si[i])
		} else {
			return res
		}
	}
	return res
}

// TakeLast returns a new Accounts that contains the last count elements from source.
func (si Accounts) TakeLast(n int) Accounts {
	if n < 0 || n >= len(si) {
		panic("Linq: TakeLast() out of index")
	}
	return si.Skip(len(si) - n)
}

// Skip bypasses a specified number of elements in a sequence and then returns the remaining elements.
func (si Accounts) Skip(n int) Accounts {
	if n < 0 || n >= len(si) {
		panic("Linq: Skip() out of index")
	}
	return si[n:]
}

// SkipWhile bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements.
func (si Accounts) SkipWhile(predicate func(models.Account) bool) Accounts {
	for i := 0; i < len(si); i++ {
		if predicate(si[i]) {
			continue
		} else {
			return si[i:]
		}
	}
	return Accounts{}
}

// SkipLast returns a new enumerable collection that contains the elements from source with the last count elements of the source collection omitted.
func (si Accounts) SkipLast(n int) Accounts {
	if n < 0 || n > len(si) {
		panic("Linq: SkipLast() out of index")
	}
	return si.Take(len(si) - n)
}

// SumInt32 computes the sum of a sequence of numeric values.
func (si Accounts) SumInt32(selector func(models.Account) int32) int32 {
	var sum int32
	for _, elem := range si {
		sum += selector(elem)
	}
	return sum
}

// SumInt16 computes the sum of a sequence of numeric values.
func (si Accounts) SumInt16(selector func(models.Account) int16) int16 {
	var sum int16
	for _, elem := range si {
		sum += selector(elem)
	}
	return sum
}

// SumInt64 computes the sum of a sequence of numeric values.
func (si Accounts) SumInt64(selector func(models.Account) int64) int64 {
	var sum int64
	for _, elem := range si {
		sum += selector(elem)
	}
	return sum
}

// SumFloat32 computes the sum of a sequence of numeric values.
func (si Accounts) SumFloat32(selector func(models.Account) float32) float32 {
	var sum float32
	for _, elem := range si {
		sum += selector(elem)
	}
	return sum
}

// SumFloat64 computes the sum of a sequence of numeric values.
func (si Accounts) SumFloat64(selector func(models.Account) float64) float64 {
	var sum float64
	for _, elem := range si {
		sum += selector(elem)
	}
	return sum
}

// ToSlice create a/an Accounts from a/an models.Account.
func (si Accounts) ToSlice() []models.Account {
	return si
}

// #region not linq

// ForEach executes the provided callback once for each element present in the Accounts in ascending order.
func (si Accounts) ForEach(callBack func(models.Account)) {
	for _, elem := range si {
		callBack(elem)
	}
}

// ReplaceAll replaces all oldValues with newValues in the Accounts.
func (si Accounts) ReplaceAll(oldValue, newValue models.Account) Accounts {
	res := NewAccounts([]models.Account{})
	for _, elem := range si {
		if reflect.DeepEqual(elem, oldValue) {
			res = res.Append(newValue)
		} else {
			res = res.Append(elem)
		}
	}
	return res
}

// Remove removes the first occurrence of a specific object from the Accounts.
func (si *Accounts) Remove(item models.Account) bool {
	res := NewAccounts([]models.Account{})
	var isRemoved bool
	for _, elem := range *si {
		if reflect.DeepEqual(elem, item) && !isRemoved {
			isRemoved = true
			continue
		}
		res = res.Append(elem)
	}
	*si = res
	return isRemoved
}

// RemoveAll removes all the elements that match the conditions defined by the specified predicate.
func (si *Accounts) RemoveAll(predicate func(models.Account) bool) int {
	var count int
	res := NewAccounts([]models.Account{})
	for _, elem := range *si {
		if predicate(elem) {
			count++
			continue
		}
		res = res.Append(elem)
	}
	*si = res
	return count
}

// RemoveAt removes the element at the specified index of the Accounts.
func (si *Accounts) RemoveAt(index int) {
	res := NewAccounts([]models.Account{})
	for i := 0; i < len(*si); i++ {
		if i == index {
			continue
		}
		res = res.Append((*si)[i])
	}
	*si = res
}

// RemoveRange removes a range of elements from the Accounts.
func (si *Accounts) RemoveRange(index, count int) error {
	if index < 0 || count < 0 || index+count > len(*si) {
		return fmt.Errorf("argument out of range")
	}
	res := NewAccounts([]models.Account{})
	for i := 0; i < len(*si); i++ {
		if i >= index && count != 0 {
			count--
			continue
		}
		res = res.Append((*si)[i])
	}
	*si = res
	return nil
}

// #endregion not linq
