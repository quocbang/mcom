package main

import (
	"fmt"
	"os"
	"reflect"
	"sort"
	"strings"

	linq "github.com/ahmetb/go-linq/v3"
	"github.com/dave/jennifer/jen"
	"github.com/psampaz/gods/sets/hashset"

	"gitlab.kenda.com.tw/kenda/mcom"
)

var pkgPath hashset.Set

func main() {
	pkgPath = *hashset.New()

	methods := getMethodList((*mcom.DataManager)(nil))
	for _, method := range methods {
		getPackagePath(method)
	}

	importedPkgs := parseImportedPackages(&pkgPath)
	importCode := make([]jen.Code, len(importedPkgs))
	for i, pkg := range importedPkgs {
		importCode[i] = jen.Id(pkg)
	}

	mock := jen.NewFile("mock")
	mock.HeaderComment(`Code generated by cmd\mockgenerator\main.go. Do NOT EDIT.`)
	mock.Line()
	mock.Id("import").Defs(importCode...)
	mock.Line()

	// #region enum_funcName
	mock.Comment(" function name list")
	enumFuncName := jen.Line()
	for _, method := range methods {
		enumFuncName.Id("Func" + method.Name).Id("FuncName").Op("=").Id("\"" + method.Name + "\"").Line()
	}
	mock.Const().Call(enumFuncName)
	// #endregion enum_funcName

	//remove Close()
	exceptions := []string{"Close", "BeginTx", "AuthUserRole", "SignInStation"}
	linq.From(methods).Where(func(m interface{}) bool {
		for _, str := range exceptions {
			if m.(reflect.Method).Name == str {
				return false
			}
		}
		return true
	}).Select(func(i interface{}) interface{} { return i.(reflect.Method) }).ToSlice(&methods)
	parseMethods(mock, methods)

	// #region create file
	file, err := os.Create("../../mock/mock_func.go")
	if err != nil {
		fmt.Println(err)
	}
	defer file.Close()
	_, err = file.WriteString(fmt.Sprintf("%#v", mock))
	if err != nil {
		panic(err)
	}
	// #endregion create file

}

// parseImportedPackages returns the sorted imported package.
func parseImportedPackages(set *hashset.Set) []string {
	vs := pkgPath.Values()

	result := make([]string, 0, len(vs))
	for _, v := range vs {
		s, _ := v.(string)
		if s == "" {
			continue
		}
		result = append(result, fmt.Sprintf("\"%s\"", s))
	}
	sort.Strings(result)
	return result
}

func getMethodList(targetInterface interface{}) []reflect.Method {
	t := reflect.TypeOf(targetInterface).Elem()
	var res []reflect.Method
	for i := 0; i < t.NumMethod(); i++ {
		res = append(res, t.Method(i))
	}
	return res
}

func parseMethods(mock *jen.File, methods []reflect.Method) {
	for _, method := range methods {
		switch getMethodSignatureType(method) {
		case DISO:
			parseMethodDISO(mock, method)
		case DIMO:
			parseMethodDIMO(mock, method)
		case TISO:
			parseMethodTISO(mock, method)
		case TIMO:
			parseMethodTIMO(mock, method)
		case SISO:
			parseMethodSISO(mock, method)
		case SIMO:
			parseMethodDIMO(mock, method)
		default:
			panic("this kind of method is currently not supported in mock generator")
		}
		mock.Line()
	}
}

func parseParameter(method reflect.Method) (codes []jen.Code) {
	amount := method.Type.NumIn()
	for i := 0; i < amount; i++ {
		op, id := getParameterKind(method.Type.In(i), method.Type.IsVariadic())
		codes = append(codes, jen.Id(getParameterName(i)).Op(op).Id(id))
		pkgPath.Add(method.Type.In(i).PkgPath())
	}
	return
}

func getParameterName(index int) string {
	switch index {
	case 0:
		return "ctx"
	case 1:
		return "req"
	case 2:
		return "opts"
	default:
		return fmt.Sprint("opts", index-1)
	}
}

func getParameterKind(methodType reflect.Type, IsVariadic bool) (operator, id string) {
	if methodType.Name() == "" {
		switch methodType.Kind() {
		case reflect.Slice:
			if IsVariadic {
				operator = "..."
			} else {
				operator = "[]"
			}
			id = methodType.Elem().String()
		case reflect.Ptr:
			operator = "*"
			id = methodType.Elem().String()
		case reflect.Map:
			id = fmt.Sprint(methodType)
		default:
			id = methodType.Elem().String()
		}
	} else {
		id = methodType.String()
	}
	return
}

func getReturnType(methodType reflect.Type) (code jen.Code) {
	if methodType.Name() == "" {
		switch methodType.Kind() {
		case reflect.Slice:
			code = jen.Op("[]").Id(methodType.Elem().String())
		case reflect.Ptr:
			code = jen.Op("*").Id(methodType.Elem().String())
		default:
			code = jen.Id(methodType.Elem().String())
		}
	} else {
		code = jen.Id(methodType.String())
	}
	return
}

func getMethodSignatureType(method reflect.Method) int {
	i := method.Type.NumIn()
	o := method.Type.NumOut()
	switch {
	case i == 1 && o == 1:
		return SISO
	case i == 1 && o == 2:
		return SIMO
	case i == 2 && o == 1:
		return DISO
	case i == 2 && o == 2:
		return DIMO
	case i == 3 && o == 1:
		return TISO
	case i == 3 && o == 2:
		return TIMO
	default:
		return NotSupported
	}
}

func parseMethodSISO(mock *jen.File, method reflect.Method) {
	panic("this kind of method is currently not supported in mock generator")
}

func parseMethodDISO(mock *jen.File, method reflect.Method) {
	params := parseParameter(method)
	blockCode := []jen.Code{}
	blockCode = append(blockCode, jen.Id("_").Op(",").Id("err").Op(":=").Id("dm.run").
		Params([]jen.Code{jen.Id("ctx"), jen.Id("Func" + method.Name), jen.Id("req"), jen.Id("noOptions"), jen.Id("noReply")}...))
	blockCode = append(blockCode, jen.If(jen.Id("err").Op("!=")).Id("nil").Block(jen.Return(jen.Id("err"))))
	blockCode = append(blockCode, jen.Return(jen.Id("nil")))
	mock.Func().Call(jen.Id("dm").Op("*").Id("dataManager")).Id(method.Name).Params(params...).Id("error").Block(blockCode...)
}

// with a few single input cases.
func parseMethodDIMO(mock *jen.File, method reflect.Method) {
	params := parseParameter(method)
	returnCode := []jen.Code{}
	returnCode = append(returnCode, getReturnType(method.Type.Out(0)))
	returnCode = append(returnCode, getReturnType(method.Type.Out(1)))

	runParamReq := "req"
	if method.Type.NumIn() == 1 {
		runParamReq = "nil"
	}

	blockCode := []jen.Code{}
	blockCode = append(blockCode, jen.Id("reply").Op(",").Id("err").Op(":=").Id("dm.run").
		Params([]jen.Code{
			jen.Id("ctx"), jen.Id("Func" + method.Name), jen.Id(runParamReq), jen.Id("noOptions"),
			jen.Func().Params([]jen.Code{jen.Id("i").Id("interface{}")}...).Id("bool").
				Block([]jen.Code{
					jen.Id("_").Op(",").Id("ok").Op(":=").Id("i").Op(".").Call([]jen.Code{returnCode[0]}...),
					jen.Return(jen.Id("ok")),
				}...),
		}...))
	blockCode = append(blockCode, jen.If(jen.Id("err").Op("!=")).Id("nil").Block(jen.Return(jen.Id(getZeroValue(method.Type.Out(0))).Op(",").Id("err"))))
	blockCode = append(blockCode, jen.Return(jen.Id("reply").Op(".").Call(returnCode[0]).Op(",").Id("nil")))

	mock.Func().Call(jen.Id("dm").Op("*").Id("dataManager")).Id(method.Name).Params(params...).Call(returnCode...).Block(blockCode...)
}

func parseMethodTISO(mock *jen.File, method reflect.Method) {
	params := parseParameter(method)
	optionArgName := strings.TrimLeft(method.Type.In(2).Elem().String(), ".[]")

	blockCode := []jen.Code{}
	blockCode = append(blockCode, jen.Id("_").Op(",").Id("err").Op(":=").Id("dm.run").
		Params([]jen.Code{
			jen.Id("ctx"), jen.Id("Func" + method.Name), jen.Id("req"),
			jen.Func().Call([]jen.Code{jen.Id("expectedOpts").Op("[]").Id("interface{}")}...).
				Call([]jen.Code{jen.Op("*").Id("parsedOptions").Op(",").Id("error")}...).
				Block([]jen.Code{
					jen.If(jen.Id("len").Call(jen.Id("opts")).Op("!=").Id("len").Call(jen.Id("expectedOpts"))).Block(jen.Return(jen.Id("nil").Op(",").Id("newMismatchInputOptionLengthError").Call(jen.Id("len").Call(jen.Id("expectedOpts")).Op(",").Id("len").Call(jen.Id("opts"))))),
					jen.Id("expectedOptions").Op(":=").Id("make").Call(jen.Op("[]").Id(optionArgName).Op(",").Id("len").Call(jen.Id("expectedOpts"))),
					jen.For(jen.Id("i").Op(",").Id("inputOpt").Op(":=").Id("range").Id("expectedOpts")).Block([]jen.Code{
						jen.Id("o").Op(",").Id("ok").Op(":=").Id("inputOpt").Op(".").Call(jen.Id(optionArgName)),
						jen.If(jen.Op("!").Id("ok")).Block(jen.Return(jen.Id("nil").Op(",").Id("badOptionType").Call(jen.Id("\"" + optionArgName + "\"")))),
						jen.Id("expectedOptions[i]").Op("=").Id("o"),
					}...),
					jen.Return(jen.Op("&").Id("parsedOptions").Block(
						jen.Id("expected").Op(":").Id("mcom.Parse" + method.Name + "Options").Call(jen.Id("expectedOptions")).Op(",").Id("actual").Op(":").Id("mcom.Parse" + method.Name + "Options(opts)").Op(","),
					).Op(",").Id("nil")),
				}...),
			jen.Id("noReply"),
		}...))
	blockCode = append(blockCode, jen.Return(jen.Id("err")))

	mock.Func().Call(jen.Id("dm").Op("*").Id("dataManager")).Id(method.Name).Params(params...).Id("error").Block(blockCode...)
}

func parseMethodTIMO(mock *jen.File, method reflect.Method) {
	params := parseParameter(method)
	returnCode := []jen.Code{}
	returnCode = append(returnCode, getReturnType(method.Type.Out(0)))
	returnCode = append(returnCode, getReturnType(method.Type.Out(1)))
	optionArgName := strings.TrimLeft(method.Type.In(2).Elem().String(), ".[]")

	blockCode := []jen.Code{}
	blockCode = append(blockCode, jen.Id("reply").Op(",").Id("err").Op(":=").Id("dm.run").
		Params([]jen.Code{
			jen.Id("ctx"), jen.Id("Func" + method.Name), jen.Id("req"),
			jen.Func().Call([]jen.Code{jen.Id("expectedOpts").Op("[]").Id("interface{}")}...).
				Call([]jen.Code{jen.Op("*").Id("parsedOptions").Op(",").Id("error")}...).
				Block([]jen.Code{
					jen.If(jen.Id("len").Call(jen.Id("opts")).Op("!=").Id("len").Call(jen.Id("expectedOpts"))).Block(jen.Return(jen.Id("nil").Op(",").Id("newMismatchInputOptionLengthError").Call(jen.Id("len").Call(jen.Id("expectedOpts")).Op(",").Id("len").Call(jen.Id("opts"))))),
					jen.Id("expectedOptions").Op(":=").Id("make").Call(jen.Op("[]").Id(optionArgName).Op(",").Id("len").Call(jen.Id("expectedOpts"))),
					jen.For(jen.Id("i").Op(",").Id("inputOpt").Op(":=").Id("range").Id("expectedOpts")).Block([]jen.Code{
						jen.Id("o").Op(",").Id("ok").Op(":=").Id("inputOpt").Op(".").Call(jen.Id(optionArgName)),
						jen.If(jen.Op("!").Id("ok")).Block(jen.Return(jen.Id("nil").Op(",").Id("badOptionType").Call(jen.Id("\"" + optionArgName + "\"")))),
						jen.Id("expectedOptions[i]").Op("=").Id("o"),
					}...),
					jen.Return(jen.Op("&").Id("parsedOptions").Block(
						jen.Id("expected").Op(":").Id("mcom.Parse" + method.Name + "Options").Call(jen.Id("expectedOptions")).Op(",").Id("actual").Op(":").Id("mcom.Parse" + method.Name + "Options(opts)").Op(","),
					).Op(",").Id("nil")),
				}...),
			jen.Func().Params([]jen.Code{jen.Id("i").Id("interface{}")}...).Id("bool").
				Block([]jen.Code{
					jen.Id("_").Op(",").Id("ok").Op(":=").Id("i").Op(".").Call([]jen.Code{returnCode[0]}...),
					jen.Return(jen.Id("ok")),
				}...),
		}...))
	blockCode = append(blockCode, jen.If(jen.Id("err").Op("!=")).Id("nil").Block(jen.Return(jen.Id(getZeroValue(method.Type.Out(0))).Op(",").Id("err"))))
	blockCode = append(blockCode, jen.Return(jen.Id("reply").Op(".").Call(returnCode[0]).Op(",").Id("nil")))

	mock.Func().Call(jen.Id("dm").Op("*").Id("dataManager")).Id(method.Name).Params(params...).Call(returnCode...).Block(blockCode...)
}

func getZeroValue(t reflect.Type) (zeroValue string) {
	switch t.Kind() {
	case reflect.Bool:
		return "false"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
		reflect.Float32, reflect.Float64:
		return "0"
	case reflect.Func, reflect.Interface, reflect.Map, reflect.Slice, reflect.Ptr:
		return "nil"
	case reflect.String:
		return `""`
	case reflect.Struct:
		return t.String() + "{}"
	}
	panic(fmt.Sprintf("unable to get the zero-value of the data type [%s]", t.Kind()))
}

func getPackagePath(method reflect.Method) {
	for i := 0; i < method.Type.NumIn(); i++ {
		pkgPath.Add(method.Type.In(i).PkgPath())
	}
	for i := 0; i < method.Type.NumOut(); i++ {
		pkgPath.Add(method.Type.Out(i).PkgPath())
	}
}

const (
	// double input and single output.
	DISO int = iota
	// double input and multiple output.
	DIMO
	// tripple input and single output.
	TISO
	// tripple input and multiple output.
	TIMO
	// single input and single output.
	SISO
	// single input and multiple output.
	SIMO
	NotSupported
)
